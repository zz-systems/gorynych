
.. _program_listing_file__home_travis_build_zz-systems_zacc_include_backend_avx2_int32.impl.hpp:

Program Listing for File int32.impl.hpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_zz-systems_zacc_include_backend_avx2_int32.impl.hpp>` (``/home/travis/build/zz-systems/zacc/include/backend/avx2/int32.impl.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //---------------------------------------------------------------------------------
   // The MIT License (MIT)
   //
   // Copyright (c) 2015-2018 Sergej Zuyev (sergej.zuyev - at - zz-systems.net)
   //
   // Permission is hereby granted, free of charge, to any person obtaining a copy
   // of this software and associated documentation files (the "Software"), to deal
   // in the Software without restriction, including without limitation the rights
   // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   // copies of the Software, and to permit persons to whom the Software is
   // furnished to do so, subject to the following conditions:
   //
   // The above copyright notice and this permission notice shall be included in all
   // copies or substantial portions of the Software.
   //
   // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   // SOFTWARE.
   //---------------------------------------------------------------------------------
   
   #pragma once
   
   #include <type_traits>
   #include <cmath>
   
   #include "backend/intrin.hpp"
   #include "backend/intrin.ext.hpp"
   #include "backend/zval.hpp"
   
   #include "util/type/type_composition.hpp"
   #include "util/type/type_traits.hpp"
   
   #include "util/memory.hpp"
   #include "util/macros.hpp"
   
   #include "system/feature.hpp"
   
   #include "traits/printable.hpp"
   #include "traits/numeric.hpp"
   #include "traits/logical.hpp"
   #include "traits/math.hpp"
   #include "traits/arithmetic.hpp"
   #include "traits/equatable.hpp"
   #include "traits/bitwise.hpp"
   #include "traits/comparable.hpp"
   #include "traits/io.hpp"
   #include "traits/bitwise_shift.hpp"
   #include "traits/conditional.hpp"
   
   namespace zacc { namespace backend { namespace avx2
   {
       template<uint64_t FeatureMask>// = last_operation::undefined>
       struct bint32;
   
       template<uint64_t FeatureMask>// = last_operation::undefined>
       struct zint32;
   
       template<uint64_t FeatureMask>// = last_operation::undefined>
       using izint32 = ztype<zval_tag, __m256i, int32_t, 8, 32, FeatureMask>;
   
       template<uint64_t FeatureMask>// = last_operation::undefined>
       using ibint32 = ztype<bval_tag, __m256i, int32_t, 8, 32, FeatureMask>;
   }}}
   
   namespace zacc {
   
       template<typename T>
       struct ztraits<T, std::enable_if_t<
               std::is_base_of<backend::avx2::izint32<std::decay_t<T>::feature_mask>, std::decay_t<T>>::value
               || std::is_base_of<backend::avx2::ibint32<std::decay_t<T>::feature_mask>, std::decay_t<T>>::value>>
       {
           static constexpr size_t size = 8;
   
           static constexpr uint64_t feature_mask = std::decay_t<T>::feature_mask;
   
           static constexpr size_t alignment = 32;
   
           static constexpr bool is_vector = size > 1;
   
           using vector_type = __m256i;
   
           using element_type = int32_t;
   
           using extracted_type = std::array<element_type, size>;
   
           using zval_type = backend::avx2::zint32<std::decay_t<T>::feature_mask>;
           using bval_type = backend::avx2::bint32<std::decay_t<T>::feature_mask>;
   
           using tag = typename std::decay_t<T>::tag;
       };
   }
   
   namespace zacc { namespace backend { namespace avx2
   {
       namespace int32_modules
       {
           template<typename Interface, typename Composed, typename Boolean>
           struct numeric : traits::numeric<Interface, Composed, Boolean>
           {
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct logical : traits::logical<Interface, Composed, Boolean>
           {
               friend Boolean vlneg(Composed one) 
               {
                   return _mm256_cmpeq_epi32(one, _mm256_setzero_si256());
               }
   
               friend Boolean vlor(Composed one, Composed other) 
               {
                   return _mm256_or_si256(one, other);
               }
   
               friend Boolean vland(Composed one, Composed other) 
               {
                   return _mm256_and_si256(one, other);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct math : traits::math<Interface, Composed, Boolean>
           {
               friend Composed vabs(Composed one) 
               {
                   return _mm256_abs_epi32(one);
               }
   
               friend Composed vmin(Composed one, Composed other) 
               {
                   return _mm256_min_epi32(one, other);
               }
   
               friend Composed vmax(Composed one, Composed other) 
               {
                   return _mm256_max_epi32(one, other);
               }
   
               friend Composed vclamp(Composed self, Composed from, Composed to) 
               {
                   return vmin(to, vmax(from, self));
               }
   
               friend Composed vsqrt(Composed one) 
               {
                   return _mm256_sqrt_ps(_mm256_cvtepi32_ps(one));
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct arithmetic : traits::arithmetic<Interface, Composed, Boolean>
           {
               friend Composed vneg(Composed one) 
               {
                   return _mm256_sub_epi32(_mm256_setzero_si256(), one);
               }
   
               friend Composed vadd(Composed one, Composed other) 
               {
                   return _mm256_add_epi32(one, other);
               }
   
               friend Composed vsub(Composed one, Composed other) 
               {
                   return _mm256_sub_epi32(one, other);
               }
   
               friend Composed vmul(Composed one, Composed other) 
               {
                   return _mm256_mullo_epi32(one, other);
               }
   
               friend Composed vdiv(Composed one, Composed other) 
               {
                   return _mm256_div_ps(_mm256_cvtepi32_ps(one), _mm256_cvtepi32_ps(other));
               }
   
               friend Composed vmod(Composed one, Composed other) 
               {
                   return vsub(one, vmul(other, vdiv(one, other)));
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct equatable : traits::equatable<Interface, Composed, Boolean>
           {
               friend Boolean veq(Composed one, Composed other) 
               {
                   return _mm256_cmpeq_epi32(one, other);
               }
   
               friend Boolean vneq(Composed one, Composed other) 
               {
                   return !(one == other);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct bitwise : traits::bitwise<Interface, Composed, Boolean>
           {
               friend Composed vbneg(Composed one) 
               {
                   auto zero = _mm256_setzero_si256();
                   auto ones = _mm256_cmpeq_epi32(zero, zero);
                   return _mm256_xor_si256(one, ones);
               }
   
               friend Composed vband(Composed one, Composed other) 
               {
                   return _mm256_and_si256(one, other);
               }
   
               friend Composed vbor(Composed one, Composed other) 
               {
                   return _mm256_or_si256(one, other);
               }
   
               friend Composed vbxor(Composed one, Composed other) 
               {
                   return _mm256_xor_si256(one, other);
               }
   
               friend bool vis_set(Composed one) 
               {
                   return _mm256_testc_si256(one, _mm256_cmpeq_epi32(one,one));
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct comparable : traits::comparable<Interface, Composed, Boolean>
           {
               friend Boolean vgt(Composed one, Composed other) 
               {
                   return _mm256_cmpgt_epi32(one, other);
               }
   
               friend Boolean vlt(Composed one, Composed other) 
               {
                   return _mm256_cmpgt_epi32(other, one);
               }
   
               friend Boolean vge(Composed one, Composed other) 
               {
                   return !(one < other);
               }
   
               friend Boolean vle(Composed one, Composed other) 
               {
                   return !(one > other);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct io : traits::io<Interface, Composed, Boolean>
           {
               template<typename OutputIt> friend void vstore(OutputIt result, Composed input) 
               {
                   _mm256_store_si256((__m256i*)&(*result), input);
               }
   
               template<typename OutputIt> friend void vstream(OutputIt result, Composed input) 
               {
                   _mm256_stream_si256((__m256i*)&(*result), input);
               }
   
               template<typename RandomIt> friend Composed vgather(RandomIt input, const zint32<Interface::feature_mask> &index,  Composed) 
               {
                   return _mm256_i32gather_epi32(&(*input), index, 4);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct bitwise_shift : traits::bitwise_shift<Interface, Composed, Boolean>
           {
               friend Composed vbsll(Composed one, Composed other) 
               {
                   return _mm256_sll_epi32(one, other);
               }
   
               friend Composed vbsrl(Composed one, Composed other) 
               {
                   return _mm256_srl_epi32(one, other);
               }
   
               friend Composed vbslli(const Composed one, const size_t other) 
               {
                   return _mm256_slli_epi32(one, other);
               }
   
               friend Composed vbsrli(const Composed one, const size_t other) 
               {
                   return _mm256_srli_epi32(one, other);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct conditional : traits::conditional<Interface, Composed, Boolean>
           {
               friend Composed vsel(Boolean condition, Composed if_value, Composed else_value) 
               {
                   return _mm256_blendv_epi8(else_value, if_value, condition);
               }
           };
       } // end int32_modules
   
       // =================================================================================================================
   
       template<uint64_t FeatureMask>
       struct zint32 : public zval<izint32<FeatureMask>>,
   
           // generic traits
           printable<izint32<FeatureMask>, zint32<FeatureMask>>,
   
           // int32 traits
           int32_modules::io<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::math<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::numeric<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::arithmetic<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::bitwise<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::bitwise_shift<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::comparable<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::equatable<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::conditional<izint32<FeatureMask>, zint32<FeatureMask>, bint32<FeatureMask>>
       {
           USING_ZTYPE(zval<izint32<FeatureMask>>);
           using zval<izint32<FeatureMask>>::zval;
   
           constexpr zint32() = default;
   
           // =============================================================================================================
   
           template<typename T, std::enable_if_t<std::is_same<T, view_t<izint32<FeatureMask>>>::value && !is_vector, void**> = nullptr>
           constexpr zint32(const T& view) noexcept
                   : zint32(view[0])
           {}
   
           template<typename T, typename std::enable_if<is_zval<T>::value, void**>::type = nullptr>
           constexpr zint32(const T& other) noexcept
                   : zint32(other.value())
           {}
   
           explicit constexpr zint32(const bval_t<izint32<FeatureMask>>& other) noexcept
                   : zint32(other.value())
           {}
   
           constexpr zint32(__m256 value) noexcept
               : zval<izint32<FeatureMask>>(_mm256_cvttps_epi32(value))
           {
           }
   
           constexpr zint32(__m256d value) noexcept
               : zval<izint32<FeatureMask>>(_mm256_castsi128_si256(_mm256_cvttpd_epi32(value)))
           {
           }
   
           constexpr zint32(int32_t value) noexcept
               : zval<izint32<FeatureMask>>(_mm256_set1_epi32(value))
           {
           }
   
           constexpr zint32(extracted_type value) noexcept
               : zval<izint32<FeatureMask>>(_mm256_load_si256((__m256i*)value.data()))
           {
           }
   
           constexpr zint32(int32_t _7, int32_t _6, int32_t _5, int32_t _4, int32_t _3, int32_t _2, int32_t _1, int32_t _0) noexcept
               : zval<izint32<FeatureMask>>(_mm256_set_epi32(_0, _1, _2, _3, _4, _5, _6, _7))
           {
           }
       };
   
       // =================================================================================================================
   
       template<uint64_t FeatureMask>
       struct bint32 : public zval<ibint32<FeatureMask>>,
   
           // generic traits
           printable<bint32<FeatureMask>, bint32<FeatureMask>>,
   
           // int32 traits
           int32_modules::io<ibint32<FeatureMask>, bint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::bitwise<ibint32<FeatureMask>, bint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::logical<ibint32<FeatureMask>, bint32<FeatureMask>, bint32<FeatureMask>>,
           int32_modules::equatable<ibint32<FeatureMask>, bint32<FeatureMask>, bint32<FeatureMask>>
       {
           USING_ZTYPE(zval<ibint32<FeatureMask>>);
           using zval<ibint32<FeatureMask>>::zval;
   
           constexpr bint32() = default;
   
           // =============================================================================================================
   
           template<typename T, std::enable_if_t<std::is_same<T, view_t<ibint32<FeatureMask>>>::value && !is_vector, void**> = nullptr>
           constexpr bint32(const T& view) noexcept
                   : bint32((view[0]))
           {}
   
           template<typename T, typename std::enable_if<is_zval<T>::value || is_bval<T>::value, void**>::type = nullptr>
           constexpr bint32(const T& other) noexcept
                   : bint32(other.value())
           {
               //static_assert(size_v<T> == 8, "Dimension mismatch");
           }
   
           constexpr bint32(__m256 value) noexcept
               : zval<ibint32<FeatureMask>>(_mm256_castps_si256(value))
           {
           }
   
           constexpr bint32(__m256d value) noexcept
               : zval<ibint32<FeatureMask>>(_mm256_castpd_si256(value))
           {
           }
   
           constexpr bint32(bool value) noexcept
               : zval<ibint32<FeatureMask>>((value ? _mm256_cmpeq_epi32(_mm256_setzero_si256(), _mm256_setzero_si256()) : _mm256_setzero_si256()))
           {
           }
       };
   
       // Validate zint32 ===================================================================================
   
   #define params 0
   
       static_assert( is_vector_v<izint32<params>> == true,    "is_vector_v<izint32> != true.");
       static_assert( is_vector_v<ibint32<params>> == true,    "is_vector_v<ibint32> != true.");
   
       static_assert( std::is_same<element_t<ibint32<params>>, int32_t>::value,    "element_t<ibint32> != int32_t.");
   
       static_assert( std::is_same<element_t<izint32<params>>, int32_t>::value,    "element_t<izint32> != int32_t.");
       static_assert( std::is_same<element_t<ibint32<params>>, int32_t>::value,    "element_t<ibint32> != int32_t.");
   
       static_assert( std::is_same<vector_t<izint32<params>>, __m256i>::value,    "vector_t<izint32> != __m256i.");
       static_assert( std::is_same<vector_t<ibint32<params>>, __m256i>::value,    "vector_t<ibint32> != __m256i.");
   
       static_assert( std::is_same<view_t<izint32<params>>, std::array<int32_t, 8>>::value,    "view_t<izint32> != std::array<int32_t, 8>.");
       static_assert( std::is_same<view_t<ibint32<params>>, std::array<bool, 8>>::value,                        "view_t<ibint32> != std::array<bool, 8>.");
   
   //
       static_assert( std::is_base_of<izint32<params>, izint32<params>>::value, "base_of<izint32> != izint32.");
       static_assert(!std::is_base_of<ibint32<params>, izint32<params>>::value, "base_of<izint32> == ibint32.");
   
       static_assert( is_zval<izint32<params>>::value, "is_zval<izint32> == false.");
       static_assert(!is_bval<izint32<params>>::value, "is_bval<izint32> != false.");
   
       static_assert( std::is_base_of<izint32<params>, zint32<params>>::value, "base_of<zint32> != izint32.");
       static_assert(!std::is_base_of<ibint32<params>, zint32<params>>::value, "base_of<zint32> == ibint32.");
   
       static_assert(zint32<params>::size == 8, "zint32::size != 8.");
       static_assert(zint32<params>::alignment == 32, "zint32::alignment != 32.");
       static_assert(zint32<params>::is_vector == true, "zint32::is_vector != true.");
   
       static_assert(std::is_same<zint32<params>::tag, zval_tag>::value, "zint32::tag != zval_tag.");
       static_assert(std::is_same<zint32<params>::vector_type, __m256i>::value, "zint32::vector_type != __m256i.");
       static_assert(std::is_same<zint32<params>::element_type, int32_t>::value, "zint32::element_type != int32_t.");
       static_assert(std::is_same<zint32<params>::extracted_type, std::array<int32_t, 8>>::value, "zint32::extracted_type != std::array<int32_t, 8>.");
   
       static_assert( is_zval<zint32<params>>::value, "is_zval<zint32> == false.");
       static_assert(!is_bval<zint32<params>>::value, "is_bval<zint32> != false.");
   
       // Validate bint32 ===================================================================================
   
       static_assert( std::is_base_of<ibint32<params>, ibint32<params>>::value, "base_of<izint32> != izint32.");
       static_assert(!std::is_base_of<izint32<params>, ibint32<params>>::value, "base_of<izint32> == ibint32.");
   
       static_assert( is_bval<ibint32<params>>::value, "is_bval<ibint32> == false.");
       static_assert(!is_zval<ibint32<params>>::value, "is_zval<ibint32> != false.");
   
       static_assert( std::is_base_of<ibint32<params>, bint32<params>>::value, "base_of<bint32> != ibint32.");
       static_assert(!std::is_base_of<izint32<params>, bint32<params>>::value, "base_of<bint32> == izint32.");
   
       static_assert(bint32<params>::size == 8, "bint32::size != 8.");
       static_assert(bint32<params>::alignment == 32, "bint32::alignment != 32.");
       static_assert(bint32<params>::is_vector == true, "bint32::is_vector != true.");
   
       static_assert(std::is_same<bint32<params>::tag, bval_tag>::value, "bint32::tag != zval_tag.");
       static_assert(std::is_same<bint32<params>::vector_type, __m256i>::value, "bint32::vector_type != __m256i.");
       static_assert(std::is_same<bint32<params>::element_type, int32_t>::value, "bint32::element_type != int32_t.");
       static_assert(std::is_same<bint32<params>::extracted_type, std::array<int32_t, 8>>::value, "bint32::extracted_type != std::array<int32_t, 8>.");
   
       static_assert( is_bval<bint32<params>>::value, "is_bval<bint32> == false.");
       static_assert(!is_zval<bint32<params>>::value, "is_zval<bint32> != false.");
   
       // Validate integral, float, double traits =========================================================================
   
       static_assert(!std::is_floating_point<int32_t>::value || is_floating_point < zint32<params>>::value, "is_floating_point<zint32> == false. [scalar = int32_t]");
       static_assert(!std::is_floating_point<int32_t>::value || !is_integral<zint32<params>>::value, "is_integral<zint32> != false. [scalar = int32_t]");
   
       static_assert(!std::is_same<int32_t, float>::value || is_float < zint32<params>>::value, "is_float<zint32> == false. [scalar = int32_t]");
       static_assert(!std::is_same<int32_t, float>::value || !is_double < zint32<params>>::value, "is_double<zint32> != false. [scalar = int32_t]");
   
       static_assert(!std::is_same<int32_t, double>::value || is_double < zint32<params>>::value, "is_double<zint32> == false. [scalar = int32_t]");
       static_assert(!std::is_same<int32_t, double>::value || !is_float < zint32<params>>::value, "is_float<zint32> != false. [scalar = int32_t]");
   
       static_assert(!std::is_integral<int32_t>::value || is_integral<zint32<params>>::value,"is_integral<zint32> == false. [scalar = int32_t]");
       static_assert(!std::is_integral<int32_t>::value || !is_floating_point < zint32<params>>::value, "is_floating_point<zint32> != false. [scalar = int32_t]");
   }}}
