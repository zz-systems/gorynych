
.. _program_listing_file__home_travis_build_zz-systems_zacc_include_backend_scalar_int8.impl.hpp:

Program Listing for File int8.impl.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_zz-systems_zacc_include_backend_scalar_int8.impl.hpp>` (``/home/travis/build/zz-systems/zacc/include/backend/scalar/int8.impl.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //---------------------------------------------------------------------------------
   // The MIT License (MIT)
   //
   // Copyright (c) 2015-2018 Sergej Zuyev (sergej.zuyev - at - zz-systems.net)
   //
   // Permission is hereby granted, free of charge, to any person obtaining a copy
   // of this software and associated documentation files (the "Software"), to deal
   // in the Software without restriction, including without limitation the rights
   // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   // copies of the Software, and to permit persons to whom the Software is
   // furnished to do so, subject to the following conditions:
   //
   // The above copyright notice and this permission notice shall be included in all
   // copies or substantial portions of the Software.
   //
   // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   // SOFTWARE.
   //---------------------------------------------------------------------------------
   
   #pragma once
   
   #include <type_traits>
   #include <cmath>
   
   #include "backend/intrin.hpp"
   #include "backend/intrin.ext.hpp"
   #include "backend/zval.hpp"
   
   #include "util/type/type_composition.hpp"
   #include "util/type/type_traits.hpp"
   
   #include "util/memory.hpp"
   #include "util/macros.hpp"
   
   #include "system/feature.hpp"
   
   #include "traits/printable.hpp"
   #include "traits/math.hpp"
   #include "traits/conditional.hpp"
   #include "traits/arithmetic.hpp"
   #include "traits/logical.hpp"
   #include "traits/bitwise.hpp"
   #include "traits/bitwise_shift.hpp"
   #include "traits/comparable.hpp"
   #include "traits/equatable.hpp"
   #include "traits/io.hpp"
   #include "traits/numeric.hpp"
   
   namespace zacc { namespace backend { namespace scalar
   {
       template<uint64_t FeatureMask>// = last_operation::undefined>
       struct bint8;
   
       template<uint64_t FeatureMask>// = last_operation::undefined>
       struct zint8;
   
       template<uint64_t FeatureMask>// = last_operation::undefined>
       using izint8 = ztype<zval_tag, std::array<int8_t, 1>, int8_t, 1, 16, FeatureMask>;
   
       template<uint64_t FeatureMask>// = last_operation::undefined>
       using ibint8 = ztype<bval_tag, std::array<int8_t, 1>, int8_t, 1, 16, FeatureMask>;
   }}}
   
   namespace zacc {
   
       template<typename T>
       struct ztraits<T, std::enable_if_t<
               std::is_base_of<backend::scalar::izint8<std::decay_t<T>::feature_mask>, std::decay_t<T>>::value
               || std::is_base_of<backend::scalar::ibint8<std::decay_t<T>::feature_mask>, std::decay_t<T>>::value>>
       {
           static constexpr size_t size = 1;
   
           static constexpr uint64_t feature_mask = std::decay_t<T>::feature_mask;
   
           static constexpr size_t alignment = 16;
   
           static constexpr bool is_vector = size > 1;
   
           using vector_type = std::array<int8_t, 1>;
   
           using element_type = int8_t;
   
           using extracted_type = std::array<element_type, size>;
   
           using zval_type = backend::scalar::zint8<std::decay_t<T>::feature_mask>;
           using bval_type = backend::scalar::bint8<std::decay_t<T>::feature_mask>;
   
           using tag = typename std::decay_t<T>::tag;
       };
   }
   
   namespace zacc { namespace backend { namespace scalar
   {
       namespace int8_modules
       {
           template<typename Interface, typename Composed, typename Boolean>
           struct math : traits::math<Interface, Composed, Boolean>
           {
               friend Composed vabs(Composed one) 
               {
                   return std::abs(one.value());
               }
   
               friend Composed vmin(Composed one, Composed other) 
               {
                   return std::min(one.value(), other.value());
               }
   
               friend Composed vmax(Composed one, Composed other) 
               {
                   return std::max(one.value(), other.value());
               }
   
               friend Composed vclamp(Composed self, Composed from, Composed to) 
               {
                   return vmin(to, vmax(from, self));
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct conditional : traits::conditional<Interface, Composed, Boolean>
           {
               friend Composed vsel(Boolean condition, Composed if_value, Composed else_value) 
               {
                   return (condition.value() ? if_value : else_value);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct arithmetic : traits::arithmetic<Interface, Composed, Boolean>
           {
               friend Composed vneg(Composed one) 
               {
                   return (-one.value());
               }
   
               friend Composed vadd(Composed one, Composed other) 
               {
                   return (one.value() + other.value());
               }
   
               friend Composed vsub(Composed one, Composed other) 
               {
                   return (one.value() - other.value());
               }
   
               friend Composed vmul(Composed one, Composed other) 
               {
                   return (one.value() * other.value());
               }
   
               friend Composed vdiv(Composed one, Composed other) 
               {
                   return (one.value() / other.value());
               }
   
               friend Composed vmod(Composed one, Composed other) 
               {
                   return (one.value() % other.value());
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct logical : traits::logical<Interface, Composed, Boolean>
           {
               friend Boolean vlneg(Composed one) 
               {
                   return (!one.value());
               }
   
               friend Boolean vlor(Composed one, Composed other) 
               {
                   return (one.value() || other.value());
               }
   
               friend Boolean vland(Composed one, Composed other) 
               {
                   return (one.value() && other.value());
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct bitwise : traits::bitwise<Interface, Composed, Boolean>
           {
               friend Composed vbneg(Composed one) 
               {
                   return (~one.value());
               }
   
               friend Composed vband(Composed one, Composed other) 
               {
                   return (one.value() & other.value());
               }
   
               friend Composed vbor(Composed one, Composed other) 
               {
                   return (one.value() | other.value());
               }
   
               friend Composed vbxor(Composed one, Composed other) 
               {
                   return (one.value() ^ other.value());
               }
   
               friend bool vis_set(Composed one) 
               {
                   return one.value() != 0;
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct bitwise_shift : traits::bitwise_shift<Interface, Composed, Boolean>
           {
               friend Composed vbsll(Composed one, Composed other) 
               {
                   return (one.value() << other.value());
               }
   
               friend Composed vbsrl(Composed one, Composed other) 
               {
                   return (one.value() >> other.value());
               }
   
               friend Composed vbslli(const Composed one, const size_t other) 
               {
                   return (one.value() << other);
               }
   
               friend Composed vbsrli(const Composed one, const size_t other) 
               {
                   return (one.value() >> other);
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct comparable : traits::comparable<Interface, Composed, Boolean>
           {
               friend Boolean vgt(Composed one, Composed other) 
               {
                   return (one.value() > other.value());
               }
   
               friend Boolean vlt(Composed one, Composed other) 
               {
                   return (one.value() < other.value());
               }
   
               friend Boolean vge(Composed one, Composed other) 
               {
                   return (one.value() >= other.value());
               }
   
               friend Boolean vle(Composed one, Composed other) 
               {
                   return (one.value() <= other.value());
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct equatable : traits::equatable<Interface, Composed, Boolean>
           {
               friend Boolean veq(Composed one, Composed other) 
               {
                   return (one.value() == other.value());
               }
   
               friend Boolean vneq(Composed one, Composed other) 
               {
                   return (one.value() != other.value());
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct io : traits::io<Interface, Composed, Boolean>
           {
               template<typename OutputIt> friend void vstore(OutputIt result, Composed input) 
               {
                   result[0] = input.value();
               }
   
               template<typename OutputIt> friend void vstream(OutputIt result, Composed input) 
               {
                   result[0] = input.value();
               }
           };
   
           // =============================================================================================================
   
           template<typename Interface, typename Composed, typename Boolean>
           struct numeric : traits::numeric<Interface, Composed, Boolean>
           {
           };
       } // end int8_modules
   
       // =================================================================================================================
   
       template<uint64_t FeatureMask>
       struct zint8 : public zval<izint8<FeatureMask>>,
   
           // generic traits
           printable<izint8<FeatureMask>, zint8<FeatureMask>>,
   
           // int8 traits
           int8_modules::io<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::math<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::numeric<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::arithmetic<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::bitwise<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::bitwise_shift<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::comparable<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::equatable<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::conditional<izint8<FeatureMask>, zint8<FeatureMask>, bint8<FeatureMask>>
       {
           USING_ZTYPE(zval<izint8<FeatureMask>>);
           using zval<izint8<FeatureMask>>::zval;
   
           constexpr zint8() = default;
   
           // =============================================================================================================
   
           template<typename T, std::enable_if_t<std::is_same<T, view_t<izint8<FeatureMask>>>::value && !is_vector, void**> = nullptr>
           constexpr zint8(const T& view) noexcept
                   : zint8(view[0])
           {}
   
           template<typename T, typename std::enable_if<is_zval<T>::value, void**>::type = nullptr>
           constexpr zint8(const T& other) noexcept
                   : zint8(other.value())
           {}
   
           explicit constexpr zint8(const bval_t<izint8<FeatureMask>>& other) noexcept
                   : zint8(other.value())
           {}
   
       };
   
       // =================================================================================================================
   
       template<uint64_t FeatureMask>
       struct bint8 : public zval<ibint8<FeatureMask>>,
   
           // generic traits
           printable<bint8<FeatureMask>, bint8<FeatureMask>>,
   
           // int8 traits
           int8_modules::io<ibint8<FeatureMask>, bint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::bitwise<ibint8<FeatureMask>, bint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::logical<ibint8<FeatureMask>, bint8<FeatureMask>, bint8<FeatureMask>>,
           int8_modules::equatable<ibint8<FeatureMask>, bint8<FeatureMask>, bint8<FeatureMask>>
       {
           USING_ZTYPE(zval<ibint8<FeatureMask>>);
           using zval<ibint8<FeatureMask>>::zval;
   
           constexpr bint8() = default;
   
           // =============================================================================================================
   
           template<typename T, std::enable_if_t<std::is_same<T, view_t<ibint8<FeatureMask>>>::value && !is_vector, void**> = nullptr>
           constexpr bint8(const T& view) noexcept
                   : bint8((view[0]))
           {}
   
           template<typename T, typename std::enable_if<is_zval<T>::value || is_bval<T>::value, void**>::type = nullptr>
           constexpr bint8(const T& other) noexcept
                   : bint8(other.value())
           {
               //static_assert(size_v<T> == 1, "Dimension mismatch");
           }
   
           constexpr bint8(zint8<FeatureMask> value) noexcept
               : zval<ibint8<FeatureMask>>(value.value() != 0)
           {
           }
       };
   
       // Validate zint8 ===================================================================================
   
   #define params 0
   
       static_assert( is_vector_v<izint8<params>> == false,    "is_vector_v<izint8> != false.");
       static_assert( is_vector_v<ibint8<params>> == false,    "is_vector_v<ibint8> != false.");
   
       static_assert( std::is_same<element_t<ibint8<params>>, int8_t>::value,    "element_t<ibint8> != int8_t.");
   
       static_assert( std::is_same<element_t<izint8<params>>, int8_t>::value,    "element_t<izint8> != int8_t.");
       static_assert( std::is_same<element_t<ibint8<params>>, int8_t>::value,    "element_t<ibint8> != int8_t.");
   
       static_assert( std::is_same<vector_t<izint8<params>>, std::array<int8_t, 1>>::value,    "vector_t<izint8> != std::array<int8_t, 1>.");
       static_assert( std::is_same<vector_t<ibint8<params>>, std::array<int8_t, 1>>::value,    "vector_t<ibint8> != std::array<int8_t, 1>.");
   
       static_assert( std::is_same<view_t<izint8<params>>, std::array<int8_t, 1>>::value,    "view_t<izint8> != std::array<int8_t, 1>.");
       static_assert( std::is_same<view_t<ibint8<params>>, std::array<bool, 1>>::value,                        "view_t<ibint8> != std::array<bool, 1>.");
   
   //
       static_assert( std::is_base_of<izint8<params>, izint8<params>>::value, "base_of<izint8> != izint8.");
       static_assert(!std::is_base_of<ibint8<params>, izint8<params>>::value, "base_of<izint8> == ibint8.");
   
       static_assert( is_zval<izint8<params>>::value, "is_zval<izint8> == false.");
       static_assert(!is_bval<izint8<params>>::value, "is_bval<izint8> != false.");
   
       static_assert( std::is_base_of<izint8<params>, zint8<params>>::value, "base_of<zint8> != izint8.");
       static_assert(!std::is_base_of<ibint8<params>, zint8<params>>::value, "base_of<zint8> == ibint8.");
   
       static_assert(zint8<params>::size == 1, "zint8::size != 1.");
       static_assert(zint8<params>::alignment == 16, "zint8::alignment != 16.");
       static_assert(zint8<params>::is_vector == false, "zint8::is_vector != false.");
   
       static_assert(std::is_same<zint8<params>::tag, zval_tag>::value, "zint8::tag != zval_tag.");
       static_assert(std::is_same<zint8<params>::vector_type, std::array<int8_t, 1>>::value, "zint8::vector_type != std::array<int8_t, 1>.");
       static_assert(std::is_same<zint8<params>::element_type, int8_t>::value, "zint8::element_type != int8_t.");
       static_assert(std::is_same<zint8<params>::extracted_type, std::array<int8_t, 1>>::value, "zint8::extracted_type != std::array<int8_t, 1>.");
   
       static_assert( is_zval<zint8<params>>::value, "is_zval<zint8> == false.");
       static_assert(!is_bval<zint8<params>>::value, "is_bval<zint8> != false.");
   
       // Validate bint8 ===================================================================================
   
       static_assert( std::is_base_of<ibint8<params>, ibint8<params>>::value, "base_of<izint8> != izint8.");
       static_assert(!std::is_base_of<izint8<params>, ibint8<params>>::value, "base_of<izint8> == ibint8.");
   
       static_assert( is_bval<ibint8<params>>::value, "is_bval<ibint8> == false.");
       static_assert(!is_zval<ibint8<params>>::value, "is_zval<ibint8> != false.");
   
       static_assert( std::is_base_of<ibint8<params>, bint8<params>>::value, "base_of<bint8> != ibint8.");
       static_assert(!std::is_base_of<izint8<params>, bint8<params>>::value, "base_of<bint8> == izint8.");
   
       static_assert(bint8<params>::size == 1, "bint8::size != 1.");
       static_assert(bint8<params>::alignment == 16, "bint8::alignment != 16.");
       static_assert(bint8<params>::is_vector == false, "bint8::is_vector != false.");
   
       static_assert(std::is_same<bint8<params>::tag, bval_tag>::value, "bint8::tag != zval_tag.");
       static_assert(std::is_same<bint8<params>::vector_type, std::array<int8_t, 1>>::value, "bint8::vector_type != std::array<int8_t, 1>.");
       static_assert(std::is_same<bint8<params>::element_type, int8_t>::value, "bint8::element_type != int8_t.");
       static_assert(std::is_same<bint8<params>::extracted_type, std::array<int8_t, 1>>::value, "bint8::extracted_type != std::array<int8_t, 1>.");
   
       static_assert( is_bval<bint8<params>>::value, "is_bval<bint8> == false.");
       static_assert(!is_zval<bint8<params>>::value, "is_zval<bint8> != false.");
   
       // Validate integral, float, double traits =========================================================================
   
       static_assert(!std::is_floating_point<int8_t>::value || is_floating_point < zint8<params>>::value, "is_floating_point<zint8> == false. [scalar = int8_t]");
       static_assert(!std::is_floating_point<int8_t>::value || !is_integral<zint8<params>>::value, "is_integral<zint8> != false. [scalar = int8_t]");
   
       static_assert(!std::is_same<int8_t, float>::value || is_float < zint8<params>>::value, "is_float<zint8> == false. [scalar = int8_t]");
       static_assert(!std::is_same<int8_t, float>::value || !is_double < zint8<params>>::value, "is_double<zint8> != false. [scalar = int8_t]");
   
       static_assert(!std::is_same<int8_t, double>::value || is_double < zint8<params>>::value, "is_double<zint8> == false. [scalar = int8_t]");
       static_assert(!std::is_same<int8_t, double>::value || !is_float < zint8<params>>::value, "is_float<zint8> != false. [scalar = int8_t]");
   
       static_assert(!std::is_integral<int8_t>::value || is_integral<zint8<params>>::value,"is_integral<zint8> == false. [scalar = int8_t]");
       static_assert(!std::is_integral<int8_t>::value || !is_floating_point < zint8<params>>::value, "is_floating_point<zint8> != false. [scalar = int8_t]");
   }}}
