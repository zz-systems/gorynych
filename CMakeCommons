cmake_minimum_required(VERSION 3.3.2)


set(CMAKE_VERBOSE_MAKEFILE on )
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED on)

option(USE_CLANG "build application with clang" ON)

if(USE_CLANG)
    set (CMAKE_C_COMPILER   "/usr/bin/clang"    CACHE string "clang compiler" FORCE)
    set (CMAKE_CXX_COMPILER "/usr/bin/clang++"  CACHE string "clang compiler" FORCE)
endif(USE_CLANG)

if(WIN32)
	#set(CMAKE_CXX_FLAGS_DEBUG 	${CMAKE_CXX_FLAGS_DEBUG}
	#							/MP 
	#							/GS 
	#							/W3 
	#							/Zc:wchar_t 
	#							/ZI 
	#							/Gm 
	#							/Od 
	#							/sdl 
	#							/Zc:inline
	#							/D "_DEBUG" 
	#							/D "_CONSOLE" 
	#							/D "_UNICODE" 
	#							/D "UNICODE" 
	#							#/D _ALLOW_RTCc_IN_STL
	#							/errorReport:prompt 
	#							/WX- 
	#							/Zc:forScope 								 
	#							/Gd 
	#							/MDd 
	##							/EHsc 
	#							/nologo)
	#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_DEBUG} /O2 /Oy /Ot /Ox /D 'NDEBUG' /D '_CONSOLE' /D '_UNICODE' /D 'UNICODE'")
	
elseif(UNIX)
	#set(CMAKE_CXX_FLAGS_DEBUG 	"${CMAKE_CXX_FLAGS_DEBUG} -g -fsanitize=undefined -fsanitize=alignment")
	#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3")
	
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=x86-64 -fPIC")
else()
endif()



macro(set_openmp)
    find_package(OpenMP)
    if (OPENMP_FOUND)
        set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
        set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    endif()
endmacro(set_openmp)

if(MSVC)
    set(fpu_flags)
    set(sse2_flags /arch:SSE2)
    set(sse3_flags /arch:SSE3)
    set(ssse3_flags /arch:SSSE3)
    set(sse4_flags /arch:SSE4)
    set(sse4fma_flags /arch:SSE4)
    set(avx1_flags /arch:AVX)
    set(avx2_flags /arch:AVX2)
else()
    set(fpu_flags)
    set(sse2_flags -msse2)
    set(sse3_flags -msse3)
    set(ssse3_flags -mssse3)
    set(sse4_flags -msse4)
    set(sse4fma_flags -mfma -msse4)
    set(avx1_flags -mfma -mavx)
    set(avx2_flags -mfma -mavx2)
endif(MSVC)


set(BRANCH_COMPILE_OPTS
        fpu_flags
        sse2_flags
        sse3_flags
        ssse3_flags
        sse4_flags
        sse4fma_flags
        avx1_flags
        avx2_flags)

set(BRANCHES
        fpu_branch
        sse2_branch
        sse3_branch
        ssse3_branch
        sse4_branch
        sse4fma_branch
        avx1_branch
        avx2_branch)

set(BRANCH_COMPILE_DEFS
        -DCOMPILE_FPU
        -DCOMPILE_SSE2
        -DCOMPILE_SSE3
        -DCOMPILE_SSSE3
        -DCOMPILE_SSE4
        -DCOMPILE_SSE4FMA
        -DCOMPILE_AVX1
        -DCOMPILE_AVX2)

macro(prepare_branches)
    message(${BRANCHES_TO_COMPILE})
    message(${BRANCH_MODULES})
        # compile all if not specified
    if(NOT BRANCHES_TO_COMPILE)
        set(BRANCHES_TO_COMPILE sse2_branch sse3_branch ssse3_branch sse4_branch sse4fma_branch avx1_branch avx2_branch)
    endif()

    list(LENGTH BRANCHES branches_count)
    math(EXPR branches_count "${branches_count} - 1")

    foreach(branch_index RANGE ${branches_count})
        list(GET BRANCHES ${branch_index} branch)

        if(${branch} IN_LIST BRANCHES_TO_COMPILE)
            message("branch: " ${branch})
            list(GET BRANCH_COMPILE_DEFS    ${branch_index} defs)
            list(GET BRANCH_COMPILE_OPTS    ${branch_index} opts)

            foreach(module_def IN ITEMS ${BRANCH_MODULES})
                list(GET module_def    0 module)
                list(GET module_def    1 source)

                set(target "${branch}_${module}")

                message("module: " ${module})
                message(STATUS "target: " ${target})
                message(STATUS "source: " ${source})
                message(STATUS "defines: " ${defs})
                message(STATUS "options: " ${opts})

                add_library(${target} OBJECT ${source})

                target_compile_definitions(${target} PUBLIC ${defs} ${BRANCH_ADDITIONAL_DEFS})

                foreach(compile_flag IN LISTS ${opts})
                    target_compile_options(${target} PUBLIC ${compile_flag})
                endforeach(compile_flag)

                list(APPEND SOURCE_FILES $<TARGET_OBJECTS:${target}>)
            endforeach(module_def)
        else()
            message("nope")
        endif()
    endforeach(branch_index)
endmacro(prepare_branches)

macro(prepare_doc doc_target_name)
    find_package(Doxygen)
    if(DOXYGEN_FOUND)
        configure_file(doc/Doxyfile.in ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile @ONLY)

        configure_file(doc/header.html                              ${CMAKE_CURRENT_BINARY_DIR}/header.html @ONLY)
        configure_file(doc/footer.html                              ${CMAKE_CURRENT_BINARY_DIR}/footer.html @ONLY)
        configure_file(doc/doxy-boot.js ${CMAKE_CURRENT_BINARY_DIR}/doxy-boot.js @ONLY)
        configure_file(doc/customdoxygen.css ${CMAKE_CURRENT_BINARY_DIR}/customdoxygen.css @ONLY)

        add_custom_target(gorynych_doc#${doc_target_name}
                ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile
                WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
                COMMENT "Generating API documentation with Doxygen" VERBATIM
                )
    endif(DOXYGEN_FOUND)
endmacro(prepare_doc)