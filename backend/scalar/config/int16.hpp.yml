type:
  type: int16
  branch: scalar
  vector_t: &vector_t short
  scalar_t: &scalar_t short
  vec_size: &vec_size 1
  alignment: 4
#-----------------------------------------------------------------------------------------------------------------------
  traits:
     external:
      - printable
      - iteratable
      - convertable
     internal:
       - io
       - arithmetic
       - bitwise
       - bitwise_shift
       #- logical
       - comparison
       - conditional
#-----------------------------------------------------------------------------------------------------------------------
modules:
  construction:
    - args: [[*scalar_t, value]]
      init: value
#-----------------------------------------------------------------------------------------------------------------------
  io:
    store: &io_store
      returns: void
      member: true
      suffix: const
      args: { raw: "typename base_t::extracted_t &target" }
      body: target.data()[0] = base_t::_value;
    stream: *io_store
#-----------------------------------------------------------------------------------------------------------------------
  arithmetic:
    negate:
      args: one
      body: -one.get_value();
    add: one.get_value() + other.get_value();
    sub: one.get_value() - other.get_value();
    mul: one.get_value() * other.get_value();
    div: one.get_value() / other.get_value();
#-----------------------------------------------------------------------------------------------------------------------
  bitwise:
    negate:
      args: one
      body: ~one.get_value();
    and:  one.get_value() & other.get_value();
    or:   one.get_value() | other.get_value();
    xor:  one.get_value() ^ other.get_value();
#-----------------------------------------------------------------------------------------------------------------------
  bitwise_shift:
    sll:  one.get_value() << other.get_value()
    srl:  one.get_value() >> other.get_value()
    slli:
      args: { raw: "const composed_t one, const size_t other" }
      body: one.get_value() << other
    srli:
      args: { raw: "const composed_t one, const size_t other" }
      body: one.get_value() >> other
#-----------------------------------------------------------------------------------------------------------------------
#  logical:
#    negate:
#      args: one
#      body: "!one.get_value()"
#    or:   one.get_value() || other.get_value();
#    and:  one.get_value() && other.get_value();
#-----------------------------------------------------------------------------------------------------------------------
  comparison:
    eq:   one.get_value() == other.get_value();
    neq:  one.get_value() != other.get_value();
    gt:   one.get_value() > other.get_value();
    lt:   one.get_value() < other.get_value();
    ge:   one.get_value() >= other.get_value();
    le:   one.get_value() <= other.get_value();
#-----------------------------------------------------------------------------------------------------------------------
  conditional:
     vsel:
        args: [condition, if_value, else_value]
        mangling: false
        body: "(condition.get_value() != 0 ? if_value : else_value)"