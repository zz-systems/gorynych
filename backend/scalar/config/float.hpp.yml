config:
  type: gen_float
  target: scalar
  implementation:
    arithmetic:
      negate:
        type: unary
        instruction: -one.get_value();
      add: one.get_value() + other.get_value();
      sub: one.get_value() - other.get_value();
      mul: one.get_value() * other.get_value();
      div: one.get_value() / other.get_value();
    bitwise:
      negate:
        type: unary
        instruction: ~one.get_value();
      and:  one.get_value() & other.get_value();
      or:   one.get_value() | other.get_value();
      xor:  one.get_value() ^ other.get_value();
    logical:
      negate:
        type: unary
        instruction: "!one.get_value()"
      or:   one.get_value() || other.get_value();
      and:  one.get_value() && other.get_value();
    comparison:
      eq:   one.get_value() == other.get_value();
      neq:  one.get_value() != other.get_value();
      gt:   one.get_value() > other.get_value();
      lt:   one.get_value() < other.get_value();
      ge:   one.get_value() >= other.get_value();
      le:   one.get_value() <= other.get_value();
    conditional:
      vsel:
        type: custom
        args: [condition, if_value, else_value]
        prefix: false
        modifier: friend
        instruction: "condition ? if_value : else_value"
    io:
      store: &io_store
        returns: void
        args: typename base_t::extracted_type &target
        instruction: target.data()[0] = base_t::_value;
      stream: *io_store