config:
  type: gen_int
  target: scalar
  implementation:
    arithmetic:
      negate:
        type: unary
        instruction: -one.get_value();
      add: one.get_value() + other.get_value();
      sub: one.get_value() - other.get_value();
      mul: one.get_value() * other.get_value();
      div: one.get_value() / other.get_value();
    bitwise:
      negate:
        type: unary
        instruction: ~one.get_value();
      and:  one.get_value() & other.get_value();
      or:   one.get_value() | other.get_value();
      xor:  one.get_value() ^ other.get_value();
      sll:  one.get_value() << other.get_value()
      srl:  one.get_value() >> other.get_value()
      slli:
        type: custom
        args: const composed_t one, const size_t other
        instruction: one.get_value() << other
      srli:
        type: custom
        args: const composed_t one, const size_t other
        instruction: one.get_value() >> other
    logical:
      negate:
        type: unary
        instruction: "!one.get_value()"
      or:   one.get_value() || other.get_value();
      and:  one.get_value() && other.get_value();
    comparison:
      eq:   one.get_value() == other.get_value();
      neq:  one.get_value() != other.get_value();
      gt:   one.get_value() > other.get_value();
      lt:   one.get_value() < other.get_value();
      ge:   one.get_value() >= other.get_value();
      le:   one.get_value() <= other.get_value();
    conditional:
       vsel:
          type: custom
          args: [condition, if_value, else_value]
          prefix: false
          modifier: friend
          instruction: "condition ? if_value : else_value"
    io:
      store: &io_store
        returns: void
        args: typename base_t::extracted_type &target
        instruction: target.data()[0] = base_t::_value;
      stream: *io_store