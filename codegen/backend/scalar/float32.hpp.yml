type:
  type: float32
  branch: scalar
  vector_t: &vector_t float
  mask_t: &mask_t bool
  scalar_t: &scalar_t float
  vec_size: &vec_size 1
  alignment: 8
#-----------------------------------------------------------------------------------------------------------------------
  traits:
     external:
      - printable
      - iteratable
      - convertable
     internal:
       - io
       - math
       - numeric
       - arithmetic
       #- bitwise
       #- logical
       - comparison
       - conditional
#-----------------------------------------------------------------------------------------------------------------------
modules:
  construction:
    - args: []
      init: ""

    - args: [[*scalar_t, value]]
      init: value
#-----------------------------------------------------------------------------------------------------------------------
  io:
    vstore: &io_store
      returns: void
      args: { raw: "typename base_t::extracted_t &target, composed_t source" }
      body: target.data()[0] = source.get_value();
    vstream: *io_store
#-----------------------------------------------------------------------------------------------------------------------
  numeric: {} #dummy
#-----------------------------------------------------------------------------------------------------------------------
  math:
    vabs:
      args: one
      body: std::abs(one)
    vrcp:
      args: one
      body: (1 / one)
    vtrunc:
      args: one
      body: std::trunc(one)
    vfloor:
      args: one
      body: std::floor(one)
    vceil:
      args: one
      body: std::ceil(one)
    vround:
      args: one
      body: std::round(one)
    vsqrt:
      args: one
      body: std::sqrt(one)
#-----------------------------------------------------------------------------------------------------------------------
  arithmetic:
    vneg:
      args: one
      body: (-one);
    vadd: (one + other);
    vsub: (one - other);
    vmul: (one * other);
    vdiv: (one / other);
    vfmadd:
      args: [multiplicand, multiplier, addendum]
      body: std::fma(multiplicand, multiplier, addendum)
    vfmsub:
      args: [multiplicand, multiplier, addendum]
      body: std::fma(multiplicand, multiplier, -addendum)
#-----------------------------------------------------------------------------------------------------------------------
#  bitwise:
#    vneg:
#      args: one
#      body: ~one;
#    vand:  one & other;
#    or:   one | other;
#    xor:  one ^ other;
#-----------------------------------------------------------------------------------------------------------------------
#  logical:
#    vlneg:
#      args: [[*mask_t, one]]
#      body: "!one"
#    vlor:   one || other;
#    vland:  one && other;
#-----------------------------------------------------------------------------------------------------------------------
  comparison:
    veq:   (one == other);
    vneq:  (one != other);
    vgt:   (one > other);
    vlt:   (one < other);
    vge:   (one >= other);
    vle:   (one <= other);
#-----------------------------------------------------------------------------------------------------------------------
  conditional:
    vsel:
      args: [condition, if_value, else_value]
      mangling: false
      body: "(condition.get_value() != 0 ? if_value : else_value)"
#-----------------------------------------------------------------------------------------------------------------------
