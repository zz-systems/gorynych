type:
  type: int16
  branch: scalar
  vector_t: &vector_t short
  mask_t: &mask_t bool
  scalar_t: &scalar_t short
  vec_size: &vec_size 1
  alignment: 8
#-----------------------------------------------------------------------------------------------------------------------
  traits:
     external:
      - printable
      - iteratable
      - convertable
     internal:
       - io
       - arithmetic
       - bitwise
       - bitwise_shift
       #- logical
       - comparison
       - conditional
#-----------------------------------------------------------------------------------------------------------------------
modules:
  construction:
    - args: [[*scalar_t, value]]
      init: value
#-----------------------------------------------------------------------------------------------------------------------
  io:
    vstore: &io_store
      returns: void
      member: true
      suffix: const
      args: { raw: "typename base_t::extracted_t &target, composed_t source" }
      body: target.data()[0] = base_t::_value;
    vstream: *io_store
#-----------------------------------------------------------------------------------------------------------------------
  arithmetic:
    vnegate:
      args: one
      body: -one;
    vadd: one + other;
    vsub: one - other;
    vmul: one * other;
    vdiv: one / other;
#-----------------------------------------------------------------------------------------------------------------------
  bitwise:
    vnegate:
      args: one
      body: ~one;
    vand:  one & other;
    vor:   one | other;
    vxor:  one ^ other;
#-----------------------------------------------------------------------------------------------------------------------
  bitwise_shift:
    vsll:  one << other
    vsrl:  one >> other
    vslli:
      args: { raw: "const composed_t one, const size_t other" }
      body: one << other
    vsrli:
      args: { raw: "const composed_t one, const size_t other" }
      body: one >> other
#-----------------------------------------------------------------------------------------------------------------------
  logical:
    vnegate:
      args: one
      returns: *mask_t
      body: "!one"
    vor:
      returns: *mask_t
      body: one || other;
    vand:
      returns: *mask_t
      body: one && other;
#-----------------------------------------------------------------------------------------------------------------------
  comparison:
    veq:   one == other;
    vneq:  one != other;
    vgt:   one > other;
    vlt:   one < other;
    vge:   one >= other;
    vle:   one <= other;
#-----------------------------------------------------------------------------------------------------------------------
  conditional:
     vsel:
        args: [condition, if_value, else_value]
        mangling: false
        body: "(condition != 0 ? if_value : else_value)"